<#@ template  debug="true" hostSpecific="true" language="C#" #><#@ Assembly Name="System.Core" #><#@ Assembly Name="System.Windows.Forms" #><#@ assembly name="Ultramarine.Workspaces" #><#@ assembly name="Ultramarine.Workspaces.VisualStudio" #><#@ assembly name="NetStandard" #><#@ import namespace="System" #><#@ import namespace="System.IO" #><#@ import namespace="System.Diagnostics" #><#@ import namespace="System.Linq" #><#@ import namespace="System.Reflection" #><#@ import namespace="System.Collections" #><#@ import namespace="System.Collections.Generic" #><#@ import namespace="Ultramarine.Workspaces.CodeElements" #><#@ import namespace="Ultramarine.Workspaces.VisualStudio.CodeElements" #> <#@parameter name="Input" type="System.Object" #>//This is a schema generated by a tool, should not be modified<# 	var taskList = Input as List<ICodeElementModel>;#>{  "definitions": {       "task": {      "type": [        "object",        "null"      ],      "properties": {        "name": {          "type": [            "string",            "null"          ]        },        "description": {          "type": [            "string",            "null"          ]        },        "input": {},        "output": {},        "parent": {          "$ref": "#/definitions/task"        },        "connectedWith": {          "type": [            "string",            "null"          ]        }              },      "required": [        "name"      ]    },    "variable": {      "type": [        "object",        "null"      ],      "properties": {        "Key": {          "type": [            "string",            "null"          ]        },        "Value": {}      },      "required": [        "Key",        "Value"      ]    }  },  "type": "object",  "properties": {    "tasks": {      "definitions": {                "task": {          "type": [            "object",            "null"          ],          "properties": {            "name": {              "type": [                "string",                "null"              ]            },            "description": {              "type": [                "string",                "null"              ]            },            "input": {},            "output": {},            "parent": {              "$ref": "#/properties/tasks/definitions/task"            },            "connectedWith": {              "type": [                "string",                "null"              ]            },            "variables": {              "type": [                "array",                "null"              ],              "items": {                "type": [                  "object",                  "null"                ],                "properties": {                  "Key": {                    "type": [                      "string",                      "null"                    ]                  },                  "Value": {}                },                "required": [                  "Key",                  "Value"                ]              }            }          },          "required": [  ]        },        "Variable": {          "$ref": "#/properties/tasks/definitions/task/properties/variables/items"        }      },      "type": "array",      "items": {		"anyOf": [<# foreach(CodeElementModel task in taskList) { #>			{		  "definitions": {},		  "type": "object",		  "title": "The <#= task.Name #> Schema",		  "properties": {<# 	if(task.Name == "Iterator") { #>				"$ref": "#/properties"<# 	} else {	var properties = task.Children.Where(c => c.Type == ElementType.Property).ToList();	foreach(CodeElementModel property in properties) { 		var propertyName = ToCamelCase(property.Name);			var propertyTypes = GetPropertyDescriptor(property);	#>			"<#= propertyName #>": {				"type": [				<# 	foreach(var type in propertyTypes) { #>					"<#= type #>",	<# 	} #>				]			},	<# 		}	#>		"$ref": "#/definitions/task/properties"	,				"required": [ "name"]<# 	}#>              }	},<# 	} #>	   ]      }	},    "name": {      "type": [        "string",        "null"      ]    },    "description": {      "type": [        "string",        "null"      ]    },    "input": {},    "output": {},    "parent": {      "$ref": "#/definitions/task"    },    "connectedWith": {      "type": [        "string",        "null"      ]    },    "variables": {      "type": [        "array",        "null"      ],      "items": {        "$ref": "#/definitions/variable"      }    }  },  "required": [    "tasks",    "name"  ]}<#+ private static string ToCamelCase(string value) {	return Char.ToLowerInvariant(value[0]) + value.Substring(1);}private static Dictionary<Type, string> GetAliases(){
	return new Dictionary<Type, string>() {
		{ typeof(byte), "byte" },
		{ typeof(sbyte), "sbyte" },
		{ typeof(short), "short" },
		{ typeof(ushort), "ushort" },
		{ typeof(int), "int" },
		{ typeof(uint), "uint" },
		{ typeof(long), "long" },
		{ typeof(ulong), "ulong" },
		{ typeof(float), "float" },
		{ typeof(double), "double" },
		{ typeof(decimal), "decimal" },
		{ typeof(object), "object" },
		{ typeof(bool), "bool" },
		{ typeof(char), "char" },
		{ typeof(string), "string" },
		{ typeof(void), "void" }
	};
}private static List<string> GetPropertyDescriptor(ICodeElementModel property){	Debug.WriteLine("GetPropertyDescriptor called");	var result = new List<string>();	Debug.WriteLine("Has Property: " + property != null); 	if(property.Type == ElementType.Property)    {		Debug.WriteLine(property.TypeOf);		foreach( var type in property.TypeOf)        {
			var t = Type.GetType(type);			Debug.WriteLine(t);			if(t.IsEnum)            {
				Debug.WriteLine("Type is enum");
				var enums = Enum.GetValues(t);				result.AddRange(((string[])enums).ToList());            }			else            {				result.Add(TryGetAlias(type));            }		}	}	else    {		//TODO...	}	result.Add("null");	return result;}private static string TryGetAlias(string typeName) {
	var aliases = GetAliases();
	var key = aliases.Keys.FirstOrDefault(c => c.FullName == typeName);
	return key != null ? aliases[key] : typeName;
}#>